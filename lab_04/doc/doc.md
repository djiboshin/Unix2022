# Реквизиты

Игошин Владимир Дмитриевич, 3 курс, z33434, 2022

# Наименование

[C++ & UNIX]: C++ PROCESSES / THREADS

# Цель

Познакомить студента с принципами параллельных вычислений. Составить несколько программ в простейшими вычислительными действиями, чтобы освоить принципы параллельных вычислений (когда одни алгоритмы зависят / не зависят от других).

# Задача

1.  [С++ SEQUENCE] Последовательные вычисления
    Требуется последовательно выполнить вычисления по формуле 1, вычисления по формуле 2, после чего выполнить вычисления по формуле 3, которые выглядят следующим образом: результат вычислений 1 + результат вычислений 2 – результат вычислений 1

        Выполнить последовательно на 10 000 итераций и 100 000 итераций

    Формула 1: f(x) = x^2-x^2+x*4-x*5+x+x
    Формула 2: f(x) = x+x
    Вывести длительность выполнения всех 10 000 итераций и 100 000 итераций в сек.

2.  [C++ THREADS] Параллельные вычисления через потоки
    Требуется параллельно (насколько возможно с помощью потоков) выполнить вычисления по формуле 1, вычисления по формуле 2, после чего выполнить вычисления по формуле 3, которые выглядят следующим образом: результат вычислений 1 + результат вычислений 2 – результат вычислений 1

        Выполнить последовательно на 10 000 итераций и 100 000 итераций

    Формула 1: f(x) = x^2-x^2+x*4-x*5+x+x
    Формула 2: f(x) = x+x
    Вывести длительность выполнения всех 10 000 итераций и 100 000 итераций в сек. в разбивке по шагам вычислений 1, 2 и 3

3.  [C++ PROCESS] Параллельные вычисления через процессы
    Требуется параллельно (насколько возможно с помощью процессов) выполнить вычисления по формуле 1, вычисления по формуле 2, после чего выполнить вычисления по формуле 3, которые выглядят следующим образом: результат вычислений 1 + результат вычислений 2 – результат вычислений 1

        Выполнить последовательно на 10 000 итераций и 100 000 итераций

    Формула 1: f(x) = x^2-x^2+x*4-x*5+x+x
    Формула 2: f(x) = x+x
    Вывести длительность выполнения всех 10 000 итераций и 100 000 итераций в сек. в разбивке по шагам вычислений 1, 2 и 3

4.  [LOG] Результат всех вышеперечисленных шагов сохранить в репозиторий (+ отчет по данной ЛР в папку doc)
    Фиксацию ревизий производить строго через ветку dev. С помощью скриптов накатить ревизии на stg и на prd. Скрипты разместить в корне репозитория. Также создать скрипты по возврату к виду текущей ревизии (даже если в папке имеются несохраненные изменения + новые файлы).

# Решение

### 1. [С++ SEQUENCE] Последовательные вычисления

Код в файле `sequence.cpp`. Используется cli, можно передать один или два аргумента:

- значение x, для которого вычисляются формулы
- [опционально] значение n, количество вычислений. Если не указано, то программа выполнит вычисления для $n=10000$ и для $n=100000$

Сборка и вызов:

```bash
g++ sequence.cpp -o build/sequence
./build/sequence 5
```

Пример вывода:

```text
============================================
x=5; n=10000000; solving...
   time elapsed (s): 1.52543
   time per step (us): 0.152543
============================================
============================================
x=5; n=100000000; solving...
   time elapsed (s): 15.3761
   time per step (us): 0.153761
============================================
```

### 2. [C++ THREADS] Параллельные вычисления через потоки

Код в файле `threads.cpp`. Используется cli, можно передать один или два аргумента:

- значение x, для которого вычисляются формулы
- [опционально] значение n, количество потоков. Если не указано, то программа выполнит вычисления в одном потоке.

```bash
g++ threads.cpp -o build/threads -pthread
./build/threads 5 2
```

Пример вывода:

```text
============================================
x=5; n=10000000; solving...
   time elapsed (s): 0.767186
   time per step (us): 0.0767186
============================================
============================================
x=5; n=100000000; solving...
   time elapsed (s): 7.8306
   time per step (us): 0.078306
============================================
```

Чтобы построить зависимость скорости работы от количества потоков, был написан python скрипт `threads.py`, который вызывает программу и получает время работы из вывода этой программы. Результат `сохраняется в threads.txt`.
Пример вывода:

```text
type	threads	total time, s	time per step, us	n	x
threading	1	16.9114	0.169114	100000000.0	-2.1
threading	1	13.8707	0.138707	100000000.0	-1.0
threading	1	5.415	0.05415	100000000.0	0.0
threading	1	11.8595	0.118595	100000000.0	1.0
threading	1	15.5951	0.155951	100000000.0	5.0
```

### 3. [C++ PROCESS] Параллельные вычисления через процессы

Чтобы запустить несколько процессов одновременно и получить зависимость скорости работы от количества процессов, был написан python скрипт `process.py`, который вызывает программу, код которой в `sequence.cpp`, и получает время работы из вывода этой программы. При этом число вычислений, делется поровну на `n` процессов. Результат `сохраняется в process.txt`.
Пример вывода:

```text
type	threads	total time, s	time per step, us	n	x
processes	1	17.176716089248657	0.17176716089248656	100000000	-2.1
processes	1	13.630783319473267	0.13630783319473266	100000000	-1
processes	1	6.447542667388916	0.06447542667388917	100000000	0
processes	1	11.744545936584473	0.11744545936584473	100000000	1
processes	1	16.558375358581543	0.16558375358581542	100000000	5
```

Результаты представлены в файлах `process_data.txt` и `threads_data.txt` и на картинках `process.png` и `threads.png`.

Конечная таблица:
| type | threads/processes | total time, s | time per step, us | n | x | steps per us |
|-----------|-------------------|---------------|-------------------|-----------|---|--------------|
| sequence | 1 | 11.3082 | 0.113082 | 100000000 | 1 | 8.84314 |
| threading | 4 | 2.99946 | 0.029995 | 100000000 | 1 | 33.339334 |
| processes | 4 | 2.853652 | 0.028537 | 100000000 | 1 | 35.042809 |

### 4. [LOG] Результат всех вышеперечисленных шагов сохранить в репозиторий (+ отчет по данной ЛР в папку doc)

Использовались скрипты с прошлых лаб
